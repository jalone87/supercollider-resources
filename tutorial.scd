// *** Followign from Eli Fieldsteel - Supercollider Tutorial
// *** https://www.youtube.com/watch?v=yRzsOOiJ_p4&list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC


// starts the server // shorthand for Server.local.boot. The local server is stored in the s variable
s.boot;



// **************
// *** SYNTAX ***
// **************

// foo.bar() // Foo is the "receiver" Bar is the "message"
3.cubed // press SHIFT+RETURN to print it in console

// we create a block and can execute it all with CMD+RETURN
(
var number; // local varuable
number = 3.squared;
)

// enviroinment (global) variables. start with tilde
~globalNUmber = 1000;

// create a function in curly braces
{SinOsc.ar;};
x = {SinOsc.ar;};

// Function decclaration
(
z = {
	// first the arguments
	arg freq=440, amp=1;
	// then variable declaration
	var sig;
	// then rest
	sig = SinOsc.ar(freq) * amp
}.play()
)

// a "symbol"
\freq;

// a string
"freq"

// update parameter
z.set(\freq, 330);

// *********************
// *** DOCUMENTATION ***
// *********************

// press SHIT+CMD+D to access documentation
// or with cursor on a class or keyword press CMD+D



// *************
// *** SOUND ***
// *************

{SinOsc.ar;}.play();

// Stop it pressing COMAND + DOT

// create an Synth
x = {SinOsc.ar;};
y = x.play(); // play actually returns a synth

// stop it playiong
y.free;



// ************
// *** UGEN ***
// ************

// UGen or Unit Generators

// oscillator parameters
x = {SinOsc.ar(700, 0.0, 0.125, 0)}.play();
// skip parameters
x = {SinOsc.ar(700, mul: 0.125)}.play();
// same as
x = {SinOsc.ar(700) * 0.125}.play();


// chain ugens

(
z = {
	arg noiseHz = 8;
	var freq, sig, amp;
	//freq = LFNoise0.kr(8, 400, 600); // 8 random values per sec between [-1,1] -> [200,1000]
	// or
	//freq = LFNoise0.kr(8).range(400, 600);
	// frequencies are percieved exponentially. generate log distribution of random freq is better
	freq = LFNoise0.kr(noiseHz).exprange(200, 1000);
	amp = LFNoise1.kr(12).exprange(0.02, 1); // LFNoise1 is linearly interpolated. more gentle
	sig = SinOsc.ar(freq) * amp;
}.play;
);

// different hertz everytime we call the function
z.set(\noiseHz, exprand(4, 64));


// the {}.play() aka Function.play syntax is just a shorthand for creating a SynthDef
// SynthDef is a more ffine tuned way to create synthesizers

// recreate z using a SynthDef. This is a random note between 200 and 400 Hz (like a high string on a bass).
(
SynthDef.new(\sineTest, {
	arg noiseHz = 8;
	var freq, sig, amp;
	freq = LFNoise0.kr(noiseHz).exprange(200, 400);
	amp = LFNoise1.kr(12).exprange(0.5, 1);
	sig = SinOsc.ar(freq) * amp;
	// the only difference is that we need to explicitely declare the output
	Out.ar(0, sig) // 0 is the 0th hardware output of the available ones on the machine (eg: 0 left speaker, 1 right speaker)
}).add;
)// add the synth to the audio server. similarly also load/send/store.

// execute the synthdef
x = Synth.new(\sineTest);
x = Synth.new(\sineTest, [\noiseHz, 32]);

x.free;

// ********************
// *** TIME-LIMITED ***
// ********************

// automatically free or end a sound with `doneAction:`

(
x = {
	var sig, env;
	// Line is one type of linear Envelope __/‾‾‾\__
	// you normally only need only two of the many doneAction parameter values: 0 or 2. 0 is do nothing, 2 is free the synth
	env = Line.kr(1, 0, 1, doneAction: 2);
	sig = Pulse.ar(ExpRand(30, 500)) * env;
}.play;
)


(
x = {
	var sig, env;
	// we percieve amplitude exponentially. use an exponential envelope. exp does not work with  0!!!
	env = XLine.kr(1, 0.01, 1, doneAction: 2);
	sig = Pulse.ar(ExpRand(30, 500)) * env;
}.play;
)

// with normalized amp use XLine, with decibel (see below) use Line (since decibel are already exponential)
(
x = {
	var sig, env;
	env = Line.kr(1, -40, 1, doneAction: 2);
	sig = Pulse.ar(ExpRand(30, 500)) * env.dbamp;
}.play;
)

// conver atmp to db and viceversa
0.5.ampdb;
10.dbamp;


// multiple envelopes/doneActions: only have one 2 on the longest envelop, and 0 on all the others
(
x = {
	var sig, freq, env;
	env = XLine.kr(1, 0.01, 5, doneAction: 2); //5 sec, the longest has 2
	freq = XLine.kr(880, 110, 1, doneAction: 0); // frequency is also exponentially perceived. use XLine
	sig = Pulse.ar(freq) * env;
}.play;
)



// ***************
// *** ENV-GEN ***
// ***************
// ep 4.

// As opposite to Line and XLine EnvGen has a `gate` parameter that can trigger teh envelope and also repeat it.

// first create an Evnvelope. We can visualize the default create with `new` with `plot` method.
Env.new.plot;
// note the times must be levels.count-1, as it's the time between each level.
Env.new(levels: [0,1,0], times: [1,2], curve:'sine').plot;

(
{
	var sig, env;
	// env = EnvGen.kr(Env.new, doneAction: 2);
	// env = EnvGen.kr(Env.new([0,1,0], [1,1], 'lin'), doneAction: 2);
	env = EnvGen.kr(Env.new([0,1,0], [1,3], \sine), doneAction: 2);
	sig = Pulse.ar(ExpRand(30, 500)) * env;
}.play;
)


// using own curve points
(
{
	var sig, env;
	env = EnvGen.kr(Env.new(
		[0, 1, 0.2, 0],
		[0.5, 1, 2],
		[3, -3, 0]), // unclear but it seem to work like bizier curves when looking at the plot. with 0 meaning linear
		doneAction: 2);
	sig = Pulse.ar(ExpRand(30, 500)) * env;
}.play;
)

Env.new( [0, 1, 0.2, 0], [0.5, 1, 2], [-10, -3, 0]).plot;

// using gate to trigger a reset of the envelope
// the gate triggers when the value goes from non-positive to positive (0 and 1 is ok)
(
x = {
	// arg gate = 0
	arg t_gate = 0; // we can use t_gate to automatically reset gate to 0 so we can just set it to 1
	var sig, env;
	env = EnvGen.kr(Env.new(
		[0, 1, 0.2, 0],
		[0.5, 1, 2],
		[3, -3, 0]), t_gate);
	sig = Pulse.ar(LFPulse.kr(8).range(80, 90)) * env;
}.play;
)

x.set(\t_gate, 1); // as long as there is no doneAction and the envelope is not complete we can retrigger it as much as wanted


// ADSR Envelope
// adsr have sustain, which means that the envelope remains on the sustain value until the gate does trigger
(
x = {
	arg gate = 0;
	var sig, env;
	env = EnvGen.kr(Env.adsr, gate);
	sig = VarSaw.ar(SinOsc.kr(16).range(500, 1000)) * env;
}.play;
)

x.set(\gate, 1); // oth 1 the envelope wil start and sustain (and no sense using t_)
x.set(\gate, 0); // on zero it will gradually stop

// note Env.dadsr which is the same but with an initial delay variant

//2 different envelopes sharing the same gate
(
x = {
	arg gate = 0;
	var sig, env, freq;
	freq = EnvGen.kr(Env.adsr(1), gate, 200, 0.1);
	env = EnvGen.kr(Env.adsr, gate, doneAction: 2);
	sig = VarSaw.ar(SinOsc.kr(freq).range(30, 400)) * env;
}.play;
) // they will end together

x.set(\gate, 1);
x.set(\gate, 0);




// *********************
// *** MULTI-CHANNEL ***
// *********************
// ep 5.
// search docs for "Multichannel Expansion"

s.meter; // shows the audio levels for current channels

// following are the same. the array is expanded to the first available channels (0 and 1)
x = { [ SinOsc.ar(300), SinOsc.ar(500) ] }.play;
x = { SinOsc.ar([300, 500]) }.play;

(
x = {
	var sig, amp;
	amp = SinOsc.kr(7).range(0,1);
	// the prevoious osc only has one channel, when multiplied with the sig oscillator, which has 2,
	// the osc with less channels will apply the single one to all the others channel. same as below
	// amp = SinOsc.kr([7, 7]).range(0,1);
	sig = SinOsc.ar([300, 500]);
	sig = sig * amp;
}.play;
)

// Mixing

(
x = {
	var sig, amp;
	// given an arbitrary amount of channel. they useless if we only have 2 speakers
	amp = SinOsc.kr([7, 1, 2, 0.2, 6]).range(0,1);
	sig = SinOsc.ar([300, 500, 700, 900, 1100]);
	sig = sig * amp;
	//   we create a mixxer that sums them all to a single channel
	// Mix.new(sig) * 0.25; // 0.25 reduces clipping
	//   to bring back to 2 channels
	// [Mix.new(sig), Mix.new(sig)] * 0.25;
	//   or shortly
	// Mix.new(sig).dup(2) * 0.25;
	//   or even shorter
	// Mix.new(sig)!2 * 0.25 ;
	//   if we want to distribute the N channels *differently* to the 2 stereo ones we can use
	Splay.ar(sig) * 0.25;
}.play;
)

// note differences
x = {PinkNoise.ar(0.5)!2}.play; // same outputs both channels
x = {PinkNoise.ar(0.5!2)}.play; // different outputs for channels

x = rrand(50, 1000)!4; // same number filling an array of size 4
x = {rrand(50, 1000)}!4; // in a function, the nnumber is always different. like a callback.

// exprand and rrand will still be evaluated at compile time. outcome is always the same.
// to better use in a signal, use the Ugen
ExpRand(0.2, 12)!8; // see https://www.youtube.com/watch?v=fAXETAyrv8s min11.30 for more info

// beware that in SynthDef the Out already performs expansion.
(
SynthDef.new(\multi, {
	var sig, amp;
	amp = SinOsc.kr([7, 1, 2, 0.2, 6]).range(0,1);
	sig = SinOsc.ar([300, 500, 700, 900, 1100]);
	sig = sig * amp;
	sig = Splay.ar(sig) * 0.25;
	// So if it it finds a multichannel signal, you only need to use the initial channel (0)
	Out.ar(0, sig);
}).add;
)
x = Synth.new(\multi);


// *****************
// *** ITERATION ***
// *****************

// "do" iterates over the array and executes the function
[6, 4, 9.5, 10, 7].do{"hello".postln};
// do returns the receiver (the array) at the end

// iterate over the items
(
[6, 4, 9.5, 10, 7].do{
	arg item;
	item.squared.postln;
};
)

// enumerated
(
[6, 4, 9.5, 10, 7].do{
	arg item, count;
	[count, item.squared].postln;
};
)


// store result
x = Array.newClear(5);
(
[6, 4, 9.5, 10, 7].do{
	arg item, count;
	x[count] = item.squared;
};
)
x.postln;

//or better
(
z = [6, 4, 9.5, 10, 7].collect{
	arg item, count;
	item.squared;
};
)
//or better
z = [6, 4, 9.5, 10, 7].collect(_.squared);

// we can iterate onver integers as well. they are like ranges
5.do{"hi".postln;}

//shows currently active Synths
s.plotTree;

x.free
s.freeAll;
s.quit;










